[🔙 返回](../README.md)

# 指针

## 1. 指针的本质
### 1.1 定义
  - 指针：一个变量的地址，称为该变量的“指针”；
  - 指针变量：是一种特殊的变量，用来存放变量的地址；
    - 直接访问：按变量地址存储变量值的方式；
    - 间接访问：将变量 i 的地址存放到另一个变量中。
  - 指针变量的定义格式：
    - ``` C
      // 基类型 *指针变量名;
      int *i;

      /*
        假设变量 j 的地址值为 1000，
        用变量 k 存储变量 j 的地址值（1000），则称变量 k 为指针变量。
        间接访问：用 *k 可以访问变量 j 的值（5）。
        & 符号是取地址操作符。
      */
      int j = 5;
      int *k = &j;
      ```
  - 指针变量的**初始化**：即某个变量取地址。
### 1.2 取地址操作符与取值操作符
  - 取地址操作符 `&`
    - 也称引用，通过该操作符，可获取一个变量的**地址值**；
  - 取值操作符 `*`
    - 也称解引用，通过该操作符，可获取一个地址对应的**数据**；
  - 一些注意点
    - 指针变量前面的 `*` 表示该变量为指针型变量；
      ``` C
      // 指针变量名是 i，而不是 *i
      int *i;
      ```
    - 定义指针变量时，必须指定其类型。比如，只有整型变量的地址才能存放到指向整型变量的指针变量中；
      ``` C
      // 正确示范
      int i;
      int *p;
      p = &i;

      // 错误示范
      float f;
      int *q;
      q = &f;
      ```
    - `&` 和 `*` 两个运算符的优先级相同，要按自右向左的方向结合。
      ``` C
      // 假设运行了以下这一句代码
      i_pointer = &i;

      /*
        1. &*i_pointer 的含义：
          &*i_pointer 与 &i 是相同的，都表示变量 i 的地址，即 i_pointer。
        2. *&i 的含义：
          *&i 与 *i_pointer 的作用一样，都等价于变量 i，即 *&i 与 i 等价。
      */
      ```
    - 声明多个指针变量
      ``` C
      // 正确示范
      int *a, *b, *c;

      // 错误示范，以下写法仅声明一个指向整型变量的指针变量 a
      int* a, b, c;
      ```

## 2. 指针的使用场景
> 一级指针的使用场景是传递与偏移，服务的对象是整型变量、浮点型变量、字符型变量等。
### 2.1 指针的传递
  - C语言中的函数调用方式是值传递！
  - 具体示例见 [code/day08/main.c](../code/day08/main.c)。
### 2.2 指针的偏移
  - 含义：对指针的加减称为指针的偏移（指针即地址），加就是向后偏移，减就是向前偏移；
  - 简单理解：
    ``` C
    // p 指向 a 的第一个元素可写为：p = a
    
    int a[3] = {3, 4, 5};
    int *p;

    p = &a[1];    // p 指向 a 的第二个元素，即 p 取 a 的第二个元素的地址
    p = p - 1;    // 指针向前偏移一位，即 p 指向 a 的第一个元素

    printf("%d\n", *p);   // 输出 p 当前指向的元素数据，即 输出3。
    ```
  - 具体示例见 [code/day08/main.c](../code/day08/main.c)。
### 2.3 指针与一维数组
  - C语言中函数调用本质是值传递；
  - 数组传递是弱化为指针的。
    ``` C
    #include <stdio.h>

    void change(char *d)
    {
      *d = 'H';
      d[1] = 'E';
      *(d+2) = 'L';
    }

    int main()
    {
      char c[20] = "hello world";
      change(c);              // 数组传递
      printf("%s\n", c);      // 输出 HELlo world
      return 0;
    }
    ```
### 2.4 指针与动态内存申请
  - **栈空间**和**堆空间**
    - **栈空间**：栈空间的大小在编译时是确定的。比如数组长度固定，是因为其定义的数据类型（整型、浮点型和字符型）变量、数组变量都在栈空间中；
    - **堆空间**：若使用的空间大小不确定，就使用堆空间；
    - 关于管理，栈空间由系统自动管理，而堆空间的申请和释放需要自行管理；
    - 关于效率，栈的效率比较高（计算机在底层对栈提供支持），堆的效率明显比栈低（堆是C/C++函数库提供的数据结构，其机制很复杂）。
    - 栈空间与堆空间的差异：
      - 栈空间会随着函数执行的结束而释放；
      - 堆空间如果没有使用 `free` 函数来进行空间释放，则会一直存在内存中。
  - `malloc` 函数和 `free` 函数
    - 使用 `malloc` 函数动态申请堆空间，可实现动态数组；
    - 使用 `free` 释放 `malloc` 函数动态申请的堆空间；
    - `malloc` 函数和 `free` 函数的头文件及格式：
      - ``` C
        #include <stdlib.h>

        void *malloc(size_z size);    // size 的单位是字节
        void free(void *ptr);
        ```
    - `void` 和 `void*`
      - `void` 什么都不用返回；
      - `void*` 无类型指针，只能用来存储一个地址而不能进行偏移。如果确定好了用 `malloc` 申请的空间是用来存放什么类型的数据，都会将 `void*` 强制转换为对应的类型。
    - `free(p);` 之后，需要把 `p` 置为 `NULL`，即：
      - ``` C
        // ... 其他代码

        free(p);
        p = NULL;   // 若不这么做，则称 p 为野指针
        ```
    - `free` 时必须使用 `malloc` 申请空间时返回的指针值，不能进行任何偏移，即不能进行指针++的操作，否则程序会崩溃。
### 2.5 字符指针和字符数组的初始化
  - 字符指针和字符数组的初始化对比：
    ``` C
    char *a = "hello";      // 将字符串型常量"hello"的首地址赋给指针a
    char b[10] = "hello";   // 相当于 strcpy(b, "hello");

    b[0] = "H";             

    // 不能对常量区数据进行修改
    // a[0] = "H";

    printf("a[0] = %c\n", a[0]);      // a[0] = "h"
    printf("b[0] = %c\n", b[0]);      // b[0] = "H"

    a = "world";            // 将字符串型常量"world"的首地址赋给指针a

    // 非法
    // b = "world";

    puts(a);      // world
    ```
  - 补充点
    - 内存中，数据区、字符串常量区是只可读不可写的；
    - TODO: 操作系统关于内存管理的部分需要复盘一下。
## 3. 二级指针
> 二级指针也是一种指针，其作用自然也是传递与偏移，其服务对象更为简单，即只服务于一级指针的传递与偏移。
### 3.1 二级指针的传递
  - 具体示例见 [code/day08/main.c](../code/day08/main.c)